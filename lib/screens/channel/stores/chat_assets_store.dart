import 'dart:convert';

import 'package:frosty/api/bttv_api.dart';
import 'package:frosty/api/ffz_api.dart';
import 'package:frosty/api/seventv_api.dart';
import 'package:frosty/api/twitch_api.dart';
import 'package:frosty/models/badges.dart';
import 'package:frosty/models/emotes.dart';
import 'package:mobx/mobx.dart';
import 'package:shared_preferences/shared_preferences.dart';

part 'chat_assets_store.g.dart';

class ChatAssetsStore = _ChatAssetsStoreBase with _$ChatAssetsStore;

abstract class _ChatAssetsStoreBase with Store {
  final TwitchApi twitchApi;
  final BTTVApi bttvApi;
  final FFZApi ffzApi;
  final SevenTVApi sevenTVApi;

  /// Contains any custom FFZ mod and vip badges for the channel.
  RoomFFZ? ffzRoomInfo;

  @computed
  List<Emote> get bttvEmotes => _emoteToObject.values.where((emote) => isBTTV(emote)).toList();

  @computed
  List<Emote> get ffzEmotes => _emoteToObject.values.where((emote) => isFFZ(emote)).toList();

  @computed
  List<Emote> get sevenTVEmotes => _emoteToObject.values.where((emote) => is7TV(emote)).toList();

  /// The map of badges ids to their object representation.
  final twitchBadgesToObject = ObservableMap<String, Badge>();

  @readonly
  var _recentEmotes = ObservableList<Emote>();

  /// The map of emote words to their image or GIF URL. May be used by anyone in the chat.
  @readonly
  var _emoteToObject = <String, Emote>{};

  /// The emotes that are "owned" and may be used by the current user.
  @readonly
  var _userEmoteToObject = <String, Emote>{};

  /// The map of user IDs to their FFZ badges.
  @readonly
  var _userToFFZBadges = <String, List<Badge>>{};

  /// The map of user IDs to their 7TV badges.
  @readonly
  var _userTo7TVBadges = <String, List<Badge>>{};

  /// The map of user IDs to their BTTV badge.
  @readonly
  var _userToBTTVBadges = <String, Badge>{};

  /// The current index of the emote menu stack.
  @observable
  var emoteMenuIndex = 0;

  /// Whether or not the emote menu is visible.
  @observable
  var showEmoteMenu = false;

  bool isBTTV(Emote emote) {
    return emote.type == EmoteType.bttvChannel || emote.type == EmoteType.bttvGlobal || emote.type == EmoteType.bttvShared;
  }

  bool isFFZ(Emote emote) {
    return emote.type == EmoteType.ffzChannel || emote.type == EmoteType.ffzGlobal;
  }

  bool is7TV(Emote emote) {
    return emote.type == EmoteType.sevenTVChannel || emote.type == EmoteType.sevenTVGlobal;
  }

  late final ReactionDisposer _disposeReaction;

  _ChatAssetsStoreBase({
    required this.twitchApi,
    required this.bttvApi,
    required this.ffzApi,
    required this.sevenTVApi,
  });

  @action
  Future<void> init() async {
    // Retrieve the instance that will allow us to retrieve local search history.
    final prefs = await SharedPreferences.getInstance();

    _recentEmotes = prefs.getStringList('recent_emotes')?.map((emoteJson) => Emote.fromJson(jsonDecode(emoteJson))).toList().asObservable() ??
        ObservableList<Emote>();

    _disposeReaction = autorun((_) {
      if (_recentEmotes.length > 48) _recentEmotes.removeLast();
      prefs.setStringList('recent_emotes', _recentEmotes.map((emote) => jsonEncode(emote)).toList());
    });
  }

  /// Fetches global and channel assets (badges and emotes) and stores them in [_emoteToUrl]
  @action
  Future<void> assetsFuture({
    required String channelName,
    required String channelId,
    required Map<String, String> headers,
    required Function onEmoteError,
    required Function onBadgeError,
  }) =>
      // Fetch the global and channel's assets (emotes & badges).
      // Async awaits are placed in a list so they are performed in parallel.
      Future.wait([
        emotesFuture(
          channelName: channelName,
          channelId: channelId,
          headers: headers,
          onError: onEmoteError,
        ),
        badgesFuture(
          channelId: channelId,
          headers: headers,
          onError: onBadgeError,
        ),
      ]);

  @action
  Future<void> emotesFuture({
    required String channelId,
    required String channelName,
    required Map<String, String> headers,
    required Function onError,
  }) =>
      // Parallel futures look ugly, but are worth the performance improvement.
      // Each future has it's own catchError so that the entire future is not ended on an error.
      // This will ensure that other futures complete even if one fails.
      Future.wait([
        ffzApi.getEmotesGlobal().catchError(onError),
        bttvApi.getEmotesGlobal().catchError(onError),
        bttvApi.getEmotesChannel(id: channelId).catchError(onError),
        twitchApi.getEmotesChannel(id: channelId, headers: headers).catchError(onError),
        sevenTVApi.getEmotesGlobal().catchError(onError),
        sevenTVApi.getEmotesChannel(user: channelName).catchError(onError),
        ffzApi.getRoomInfo(name: channelName).then((ffzRoom) {
          ffzRoomInfo = ffzRoom.item1;
          return ffzRoom.item2;
        }).catchError(onError),
      ]).then((assets) => assets.expand((list) => list)).then((emotes) => _emoteToObject = {for (final emote in emotes) emote.name: emote});

  @action
  Future<void> badgesFuture({
    required String channelId,
    required Map<String, String> headers,
    required Function onError,
  }) =>
      Future.wait([
        twitchApi
            .getBadgesGlobal()
            .then((badges) => twitchBadgesToObject.addAll(badges))
            .then((_) => twitchApi.getBadgesChannel(id: channelId).then((badges) => twitchBadgesToObject.addAll(badges)).catchError(onError)),
        ffzApi.getBadges().then((badges) => _userToFFZBadges = badges).catchError(onError),
        sevenTVApi.getBadges().then((badges) => _userTo7TVBadges = badges).catchError(onError),
        bttvApi.getBadges().then((badges) => _userToBTTVBadges = badges).catchError(onError),
      ]);

  @action
  Future<void> userEmotesFuture({
    required List<String> emoteSets,
    required Map<String, String> headers,
    required Function onError,
  }) =>
      Future.wait(emoteSets.map((setId) => twitchApi.getEmotesSets(setId: setId, headers: headers).catchError(onError)))
          .then((emotes) => emotes.expand((list) => list).toList())
          .then((userEmotes) => _userEmoteToObject = {for (final emote in userEmotes) emote.name: emote}.asObservable());

  void dispose() => _disposeReaction();
}
